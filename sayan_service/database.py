# -*- coding: utf-8 -*-
""" Database module, including the SQLAlchemy database object and DB-related utilities. """

from typing import Any, Union

from datetime import datetime
from uuid import UUID

from sqlalchemy.dialects import postgresql as pg
from sqlalchemy.exc import IntegrityError, SQLAlchemyError

from .extensions import db

# Alias common SQLAlchemy names
Table = db.Table
Column = db.Column
relationship = db.relationship


class RecordNotFoundError(LookupError):
    """RecordNotFoundError

    An error thrown when a requested record is not found.
    """


class RecordInvalidError(RuntimeError):
    """RecordInvalidError

    An error thrown when the given attributes for a record do not meet schema requirements.
    """


class Model(db.Model):
    """Model

    A base model class that includes a surrogate primary key, a UUID for external use, created_at
    and updated_at automatic timestamps, and CRUD helpers for easy session management.
    """

    ##
    #: The `__abstract__` declaration tells the SQLAlchemy engine to skip the
    #: creation of a table or mapper.
    #:
    #: More information available at:
    #:   http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/api.html#abstract
    #:
    __abstract__ = True

    ##
    #: The __table_args__ specifies options to be used by SQLAlchemy when
    #: creating a table from an implementing model.
    #:
    #: By default, we specify that the attributes in this base model should act
    #: to extend any others in the hierarchy.
    #:
    __table_args__ = dict(extend_existing=True)

    ##
    #: The `NotFoundError` attribute is a shortcut for the
    #: `RecordNotFoundError`.
    #:
    NotFoundError = RecordNotFoundError

    ##
    #: The `InvalidError` attribute is a shortcut for the `RecordInvalidError`.
    #:
    InvalidError = RecordInvalidError

    ##
    #: The `id` field is a `BIGINT` surrogate primary key for unique
    #: identification of a record in a given table. It is meant to only be used
    #: internally, and should not be exposed to consumers.
    #:
    #: The `BIGINT` datatype was chosen primarily for its superior join
    #: performance over the PostgreSQL `UUID` type.
    #:
    id = db.Column(db.BigInteger, primary_key=True)

    ##
    #: The `uuid` field is a UUIDv4 identifier meant to be exposed externally to
    #: consumers.
    #:
    #: The UUID is generated by PostgreSQL with the `uuid_generate_v4()`
    #: function.
    #:
    uuid = db.Column(pg.UUID(), server_default=db.text('uuid_generate_v4()'), nullable=False, unique=True)

    ##
    #: The `created_at` timestamp field is an auto-generated timestamp to mark
    #: the time when the record was initially created in the database.
    #:
    #: The timestamp is generated by PostgreSQL with the `now()` function.
    #:
    created_at = db.Column('created_at', db.DateTime, server_default=db.text(str(db.func.now())))

    ##
    #: The `updated_at` timestamp field is an auto-generated timestamp to mark
    #: the time when the record was last updated in the database.
    #:
    #: The timestamp is initially generated by PostgreSQL with the `now()`
    #: function, but is importantly not updated if the model layer is bypassed,
    #: as with e.g. direct calls to db.session.execute().
    #:
    updated_at = db.Column('updated_at', db.DateTime, server_default=db.text(str(db.func.now())), onupdate=datetime.now)

    @classmethod
    def get_by_id(cls, record_id: Union[int, str]):
        """get_by_id

        Fetches a record by its `id` field.

        :param id:
            The `id` of the record to retrieve.
        :raises:
            RecordNotFoundError
        """
        result = None
        if cls._id_is_valid(record_id):
            result = cls.query.get(int(record_id))
        if not result:
            raise cls.NotFoundError(f'{cls.__name__} with ID {record_id} does not exist.')
        return result

    @classmethod
    def get_by_uuid(cls, record_uuid: str):
        """get_by_uuid

        Fetches a record by its `uuid` field.

        :param record_uuid:
            The `uuid` of the record to retrieve.
        :raises:
            RecordNotFoundError
        """
        result = None
        if cls._uuid_is_valid(record_uuid):
            result = cls.query.filter(cls.uuid == record_uuid).one_or_none()
        if not result:
            raise cls.NotFoundError(f'{cls.__name__} with UUID {record_uuid} does not exist.')
        return result

    @classmethod
    def create(cls, **kwargs):
        """create

        Creates a new record using the `kwargs` as attributes.

        :param kwargs:
            Keyword arguments to be used as attributes for the model.
        """
        return cls(**kwargs).save()

    def update(self, commit: bool=True, **kwargs):
        """update

        Update specific fields of a record.

        :param commit:
            If True, commits the current transaction.
        :param kwargs:
            Keyword arguments to be used to update model attributes.
        """
        for attr, value in kwargs.items():
            setattr(self, attr, value)
        return commit and self.save() or self

    def save(self, commit: bool=True):
        """save

        Persists the record to the database. By default simply adds the model
        to the current transaction. If `commit` is set to True, commits the
        transaction.

        If committing a transaction fails, the transaction is rolled back
        and an appropriate exception is raised.

        :param commit:
            If True, commits the current transaction.
        :raises:
            RecordInvalidError, SQLAlchemyError
        """
        db.session.add(self)
        if commit:
            try:
                db.session.commit()
            except IntegrityError as ex:
                db.session.rollback()
                raise self.InvalidError(
                    f'The record was unable to be saved: {str(ex)}')
            except SQLAlchemyError:
                db.session.rollback()
                raise
        return self

    def delete(self, commit: bool=True) -> bool:
        """delete

        Removes the record from the database. By default, adds the delete
        operation to the current transaction. If `commit` is set to True,
        commits the transaction.

        :param commit:
            If True, commits the current transaction.
        :rtype:
            bool
        """
        db.session.delete(self)
        return commit and db.session.commit()

    def to_dict(self) -> dict:
        """to_dict

        Returns a dictionary representation of the shallow attributes on the
        model.
        """
        mapper = self.__mapper__
        attribute_keys = mapper.columns.keys() + mapper.relationships.keys()

        return {k: getattr(self, k, None) for k in attribute_keys}

    @classmethod
    def _id_is_valid(cls, record_id: Any) -> bool:
        """_id_is_valid

        Returns True if the given `record_id` is valid, False otherwise.

        :param record_id:
            An ID to validate.
        """
        return any((isinstance(record_id, str) and record_id.isdigit(), isinstance(record_id, (int, float))))

    @classmethod
    def _uuid_is_valid(cls, record_uuid: Any) -> bool:
        """_uuid_is_valid

        Returns True if the given `record_uuid` is a valid UUIDv4, False
        otherwise.

        :param record_uuid:
            A UUID to validate.
        """
        try:
            UUID(record_uuid, version=4)
        except ValueError:
            return False
        return True


def reference_col(tablename, nullable=False, pk_name='id', schema=None, **kwargs):
    """reference_col

    Creates a foreign key reference column to the given `tablename`.

    Usage:

    .. code-block:: python

        category_id = reference_col('categories')

    :param tablename:
        The name of the table to reference.
    :param nullable:
        If set to True, allows the value of the column to be null.
    :param pk_name:
        The name of the column in the foreign table to reference.
    :param schema:
        The name of the schema in which the target table exists.
    :param `**kwargs`:
        Additional keyword arguments to set for the generated Column.
    """
    fk_column_name = f'{tablename}.{pk_name}'
    if schema is not None:
        fk_column_name = f'{schema}.{fk_column_name}'
    return db.Column(
        db.ForeignKey(fk_column_name),
        nullable=nullable,
        index=True, **kwargs)


def join_table(left_tablename, right_tablename, join_tablename=None, schema=None):
    """join_table

    Creates a join table between two tables for many-to-many relationships.

    If no `join_tablename` is given, names the table `join_{left_tablename}_with_{right_tablename}`.

    Usage:

    .. code-block:: python

        join_categories_with_items = reference_col('categories', 'items')

    :param left_tablename:
        The name of the "left" table in the join.
    :param right_tablename:
        The name of the "right" table in the join.
    :param join_tablename:
        The name of the join table itself. Defaults to join_{left_tablename}_with_{right_tablename}.
    :param schema:
        The name of the schema in which to create the table.
    """
    return Table(
        join_tablename or f'join_{left_tablename}_with_{right_tablename}',
        Model.metadata,
        reference_col(left_tablename, name=f'{left_tablename}_id', schema=schema),
        reference_col(right_tablename, name=f'{right_tablename}_id', schema=schema),
        schema=schema)
